namespace Hydrospanner.Phases.Transformation
{
	using System;
	using System.Collections.Generic;
	using Disruptor;
	using Journal;
	using log4net;
	using Timeout;

	public sealed class TransformationHandler : IEventHandler<TransformationItem>
	{
		public void OnNext(TransformationItem data, long sequence, bool endOfBatch)
		{
			//if (sequence % 100 == 0)
				Console.WriteLine(sequence);

			if (this.Skip(data))
				return;

			var liveMessage = this.Transform(data);

			if (liveMessage)
				this.PublishToJournalPhase(data);

			this.Increment(data);
		}
		private bool Skip(TransformationItem data)
		{
			if (this.skip)
				return true;

			var body = data.Body != null; // null body == serialization failure
			if (data.MessageSequence == 0 && !body)
				return true;

			return this.skip = data.MessageSequence > 0 && !body;
		}
		private bool Transform(TransformationItem data)
		{
			var live = false;

			if (data.MessageSequence == 0)
			{
				data.MessageSequence = this.currentSequnce + 1;
				live = true;
			}

			Log.DebugFormat("Transforming hydratables that subscribe to type {0}.", data.SerializedType);
			this.buffer.AddRange(this.transformer.Handle(data.Body, data.Headers, data.MessageSequence));

			// transformer ensures that messages are gathered from the hydratables only once we reach the live stream
			for (var i = 0; i < this.buffer.Count; i++)
			{
				Log.Debug("Now transforming additional hydratables that subscribe to messages generated by original and subsequent transformation.");
				this.buffer.AddRange(this.transformer.Handle(this.buffer[i], BlankHeaders, data.MessageSequence + 1 + i));
			}

			return live;
		}
		private void PublishToJournalPhase(TransformationItem data)
		{
			var offset = data.Body is CurrentTimeMessage ? 0 : IncludeIncomingMessage;
			Log.DebugFormat("Publishing {0} items to the Journal Disruptor.", this.buffer.Count + offset);

			var size = this.buffer.Count + offset;
			if (size == 0)
				return;

			var batch = this.journalRing.Next(size);

			Action confirm = null;
			if (data.Acknowledgment != null)
				confirm = () => data.Acknowledgment(true);

			if (offset > 0)
				this.journalRing[batch.Start].AsForeignMessage(
					this.currentSequnce + 1, data.SerializedBody, data.Body, data.Headers, data.ForeignId, confirm);

			for (var i = offset; i < size; i++)
				this.journalRing[i + batch.Start].AsTransformationResultMessage(this.currentSequnce + 1 + i, this.buffer[i - offset], BlankHeaders);

			this.journalRing.Publish(batch);
		}
		private void Increment(TransformationItem data)
		{
			if (data.MessageSequence > this.currentSequnce)
			{
				var offset = data.Body is CurrentTimeMessage ? 0 : IncludeIncomingMessage;
				this.currentSequnce += this.buffer.Count + offset;
				this.snapshot.Track(this.currentSequnce);
			}

			this.buffer.Clear();
		}

		public TransformationHandler(
			long journaledSequence, 
			IRingBuffer<JournalItem> journalRing,
			ITransformer transformer,
			ISystemSnapshotTracker snapshot)
		{
			if (journaledSequence < 0)
				throw new ArgumentOutOfRangeException("journaledSequence");

			if (journalRing == null)
				throw new ArgumentNullException("journalRing");

			if (transformer == null)
				throw new ArgumentNullException("transformer");

			if (snapshot == null)
				throw new ArgumentNullException("snapshot");

			this.currentSequnce = journaledSequence;
			this.journalRing = journalRing;
			this.transformer = transformer;
			this.snapshot = snapshot;
		}

		private const int IncludeIncomingMessage = 1;
		private static readonly ILog Log = LogManager.GetLogger(typeof(TransformationHandler));
		private static readonly Dictionary<string, string> BlankHeaders = new Dictionary<string, string>(); 
		private readonly IRingBuffer<JournalItem> journalRing;
		private readonly ITransformer transformer;
		private readonly ISystemSnapshotTracker snapshot;
		private readonly List<object> buffer = new List<object>();
		private long currentSequnce;
		private bool skip;
	}
}