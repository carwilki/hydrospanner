namespace Hydrospanner.Phases.Transformation
{
	using System;
	using System.Collections.Generic;
	using Disruptor;
	using Journal;
	using log4net;

	public sealed class TransformationHandler : IEventHandler<TransformationItem>
	{
		public void OnNext(TransformationItem data, long sequence, bool endOfBatch)
		{
			this.item = data;

			if (!this.CanHandle())
				return;

			if (data.MessageSequence > 0)
				this.Replay();
			else
			{
				this.Deliver();
				this.Publish();
				this.Increment();
				this.Clear();
			}
		}
		private bool CanHandle()
		{
			if (this.canHandle)
				return true;

			if (this.item.Body != null)
				return true;

			if (this.item.MessageSequence == 0)
				return false;

			return this.canHandle = false;
		}
		private void Replay()
		{
			Log.DebugFormat("Replaying hydratables that subscribe to type {0}.", this.item.SerializedType);
			this.deliveryHandler.Deliver(this.item, false);
		}
		private void Deliver()
		{
			this.offset = this.item.IsTransient ? 0 : IncludeIncomingMessage;
			var startingSequence = this.currentSequnce + this.offset;
			this.item.MessageSequence = startingSequence;

			Log.DebugFormat("Transforming hydratables that subscribe to type {0}.", this.item.SerializedType);
			this.buffer.AddRange(this.deliveryHandler.Deliver(this.item, true));

			for (var i = 0; i < this.buffer.Count; i++)
			{
				Log.Debug("Now transforming additional hydratables that subscribe to messages generated by original and subsequent transformation.");
				this.buffer.AddRange(this.deliveryHandler.Deliver(this.buffer[i], startingSequence + i + 1));
			}
		}
		private void Publish()
		{
			Log.DebugFormat("Publishing {0} items to the Journal Disruptor.", this.buffer.Count + this.offset);

			var size = this.buffer.Count + this.offset;
			if (size == 0)
				return;

			var batch = this.journalRing.Next(size);

			if (this.offset > 0)
				this.journalRing[batch.Start].AsForeignMessage(
					this.currentSequnce + 1, this.item.SerializedBody, this.item.Body, this.item.Headers, this.item.ForeignId, this.item.Acknowledgment);

			for (var i = 0; i < this.buffer.Count; i++)
			{
				var disruptorSequence = batch.Start + i + this.offset;
				var messageSequence = this.currentSequnce + 1 + i + this.offset;
				this.journalRing[disruptorSequence].AsTransformationResultMessage(messageSequence, this.buffer[i], BlankHeaders);
			}

			this.journalRing.Publish(batch);
		}
		private void Increment()
		{
			this.currentSequnce += this.buffer.Count + this.offset;
			this.snapshot.Track(this.currentSequnce);
		}
		private void Clear()
		{
			this.offset = 0;
			this.buffer.Clear();
		}

		public TransformationHandler(
			long journaledSequence, 
			IRingBuffer<JournalItem> journalRing,
			IDeliveryHandler deliveryHandler,
			ISystemSnapshotTracker snapshot)
		{
			if (journaledSequence < 0)
				throw new ArgumentOutOfRangeException("journaledSequence");

			if (journalRing == null)
				throw new ArgumentNullException("journalRing");

			if (deliveryHandler == null)
				throw new ArgumentNullException("deliveryHandler");

			if (snapshot == null)
				throw new ArgumentNullException("snapshot");

			this.currentSequnce = journaledSequence;
			this.journalRing = journalRing;
			this.deliveryHandler = deliveryHandler;
			this.snapshot = snapshot;
			this.canHandle = true;
		}

		private const int IncludeIncomingMessage = 1;
		private static readonly ILog Log = LogManager.GetLogger(typeof(TransformationHandler));
		private static readonly Dictionary<string, string> BlankHeaders = new Dictionary<string, string>(); 
		private readonly IRingBuffer<JournalItem> journalRing;
		private readonly IDeliveryHandler deliveryHandler;
		private readonly ISystemSnapshotTracker snapshot;
		private readonly List<object> buffer = new List<object>();
		private TransformationItem item;
		private long currentSequnce;
		private int offset;
		private bool canHandle;
	}
}