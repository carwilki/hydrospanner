namespace Hydrospanner.Phases.Transformation
{
	using System;
	using System.Collections.Generic;
	using Disruptor;
	using Journal;
	using log4net;

	public sealed class TransformationHandler : IEventHandler<TransformationItem>
	{
		public void OnNext(TransformationItem data, long sequence, bool endOfBatch)
		{
			this.item = data;

			if (this.Skip())
				return;

			var liveMessage = this.Transform();

			if (liveMessage)
				this.PublishToJournalPhase();

			this.Increment();
		}
		private bool Skip()
		{
			if (this.skip)
				return true;

			var body = this.item.Body != null; // null body == serialization failure
			if (this.item.MessageSequence == 0 && !body)
				return true;

			return this.skip = this.item.MessageSequence > 0 && !body;
		}
		private bool Transform()
		{
			var live = false;

			if (this.item.MessageSequence == 0)
			{
				this.item.MessageSequence = this.currentSequnce + 1;
				live = true;
			}

			Log.DebugFormat("Transforming hydratables that subscribe to type {0}.", this.item.SerializedType);
			this.buffer.AddRange(this.deliveryHandler.Deliver(this.item.Body, this.item.Headers, this.item.MessageSequence, live));

			// deliveryHandler ensures that messages are gathered from the hydratables only once we reach the live stream
			for (var i = 0; i < this.buffer.Count; i++)
			{
				Log.Debug("Now transforming additional hydratables that subscribe to messages generated by original and subsequent transformation.");
				this.buffer.AddRange(this.deliveryHandler.Deliver(this.buffer[i], BlankHeaders, this.item.MessageSequence + 1 + i, live));
			}

			return live;
		}

		private void PublishToJournalPhase()
		{
			var offset = this.item.IsTransient ? 0 : IncludeIncomingMessage;
			Log.DebugFormat("Publishing {0} items to the Journal Disruptor.", this.buffer.Count + offset);

			var size = this.buffer.Count + offset;
			if (size == 0)
				return;

			var batch = this.journalRing.Next(size);

			var ack = this.item.Acknowledgment;
			Action confirm = null;
			if (ack != null)
				confirm = () => ack(true);

			if (offset > 0)
				this.journalRing[batch.Start].AsForeignMessage(
					this.currentSequnce + 1, this.item.SerializedBody, this.item.Body, this.item.Headers, this.item.ForeignId, confirm);

			for (var i = offset; i < size; i++)
				this.journalRing[i + batch.Start].AsTransformationResultMessage(this.currentSequnce + 1 + i, this.buffer[i - offset], BlankHeaders);

			this.journalRing.Publish(batch);
		}
		private void Increment()
		{
			if (this.item.MessageSequence > this.currentSequnce)
			{
				var offset = this.item.IsTransient ? 0 : IncludeIncomingMessage;
				this.currentSequnce += this.buffer.Count + offset;
				this.snapshot.Track(this.currentSequnce);
			}

			this.buffer.Clear();
		}

		public TransformationHandler(
			long journaledSequence, 
			IRingBuffer<JournalItem> journalRing,
			IDeliveryHandler deliveryHandler,
			ISystemSnapshotTracker snapshot)
		{
			if (journaledSequence < 0)
				throw new ArgumentOutOfRangeException("journaledSequence");

			if (journalRing == null)
				throw new ArgumentNullException("journalRing");

			if (deliveryHandler == null)
				throw new ArgumentNullException("deliveryHandler");

			if (snapshot == null)
				throw new ArgumentNullException("snapshot");

			this.currentSequnce = journaledSequence;
			this.journalRing = journalRing;
			this.deliveryHandler = deliveryHandler;
			this.snapshot = snapshot;
		}

		private const int IncludeIncomingMessage = 1;
		private static readonly ILog Log = LogManager.GetLogger(typeof(TransformationHandler));
		private static readonly Dictionary<string, string> BlankHeaders = new Dictionary<string, string>(); 
		private readonly IRingBuffer<JournalItem> journalRing;
		private readonly IDeliveryHandler deliveryHandler;
		private readonly ISystemSnapshotTracker snapshot;
		private readonly List<object> buffer = new List<object>();

		private TransformationItem item;
		private long currentSequnce;
		private bool skip;
	}
}